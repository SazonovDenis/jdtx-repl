## Нерешенные вопросы (todo)

При пересоздании репликации нужно учесть ситуацию, когда в рабочей станции есть ЧУЖИЕ данныые и соответственно, чужие id
Тогда, при создании snapshot
 - эти чужие данные надо отфильтровать,
 - учесть что содержимое таблица перекодировок не должно потеряться

## Устройство репликатора


#### Объекты/методы


##### Методы

- Создать репликационные структуры

  - триггеры
  - аудит
  - таблица возрастов таблиц

  void createReplication()

- Удалить репликационные структуры

  void dropReplication()

- узнать возраст для таблицы X (может для всей БД?) для рабочей станции Z.

  long getAge(?tableName?)


- Собрать аудит и подготовить реплику по правилам публикации publication
  от возраста auditFrom до возраста auditTo включительно.

  IReplica createReplica(IPublication publication, long auditFrom, long auditTo)

- применить реплику на рабочей станции

  void applyReplica(IReplica replica)


- При включении новой БД в систему первая реплика для сервера готовится как реплика на вставку
  всех существующих записей в этой БД.

  IReplica createReplicaSnapshot(IPublication publication)



##### Реплика (IReplica)

Блок данных. Команды IDE и специальные.



##### Публикация (IPublication)

Публикация - набор правил подготовки реплик.
Публикация позволяет готовить данные как наверх, так и вниз.
В общем виде правило - это просто запрос к аудиту и left join к соответствующей таблице с данными, с наложением фильтров.

Пример правил в публикации:

```
{
    table="ABN",
    fields=["NAME", "ULZ", "DOM", "KW", "TIP"],
    filter="CITY.ID in (2, 3844) and TIP = 3"
    <-- фильтруется любая ссылка на CITY, тогда даже сами записи из CITY не проходят
},
{
    table="ABN",
    fields=["FOTO"],
    filter="ULZ.CITY in (2,3844) and TIP = 3"
    <-- фильтруется не любая ссылка на CITY, а только ссылки на ULZ из определенного CITY,
    а записи со сслками из других таблиц и сами записи из CITY - проходят.
}
```

```
select
  ABN.*
from
  LOG_ABN
  left join ABN on (LOG_ABN.ID = ABN.ID)
  left join ULZ on (ABN.ULZ = ULZ.ID)
where
  <условие по дате реплик> and
  ULZ.CITY in (2, 3844) <- реализация условия фильра ""
```


### Подходы к проблемам


##### Разведение pk

Используется перекодировка ссыллок.

```
станция 1
ins:ABN:1000

станция 2
ins:ABN:1000

станция 3
ins:ABN:1000

```

##### Порядок применения реплик

Применение реплик осуществляется потаблично, в порядке, определяемой ссылочной целостностью:

1. сначала ins и upd в порядке зависимостей: сначала "концевые" таблицы (справочиники) потом те, которые на них ссылаются
2. потом del в обратном порядке зависимостей: сначала таблицы которые ссылаются ина другие, в последнюю очередь - "концевые" (справочиники).

Именно два прохода (c отдельным del) делается для того, чтобы не вылетала целостность для ситуации, когда пришли единым блоком следующие реплики:

1. В справочник С добавлена запись С1;
2. Добавлена зависимая запись Т1->С1;
3. Удалена зависимая запись Т1->С1;
4. Потом удалена запись в справочнике С1.

Для описанного выше сценария, если не разделить ins/upd и del, то при любом порядке применения реплик
(сначала справочник С, потом зависимая Т или наоборот) возникнет ситуация, когда либо в справочнике удаляем раньше времени,
либо в зависимой вставляем раньше, чем нужно. Отдельный проход для удаления решит эту проблему.



##### Многоуровневая топология

Многоуровневая топология не создается. Вся репликационная сеть имеет один сервер, который формирует общую очередь.
Id в этой очереди определяет возраст всей сети.

Зачем??? Промежуточные узлы, если в них есть необходимость по каким-либо соображениям являются лишь _траспортными_,
т.е. "перевалочными базами" для реплик, которые все равно обслуживаются одним общим сервером.



