### Актуальность записей и отставание в применении собственных реплик

##### Суть проблемы

Если применение реплик построена не по принципу
"чье изменение самое старое, тот и прав" по принципу "кто последний отправил тот и прав"
то тогда обязательно использование единой очереди для всех рабочих станций и обязательное применение собственных реплик.

В таком случае бывает проблема: при наличии большого временного лага между текущим временем
и временем только что примененной реплики из общей очереди:
- изменяем запись в "состояние 1"
- реплика "состояние 1" отправляется на сервер
- проходит некоторое время
- изменяем запись в "состояние 2"
- реплика "состояние 2" отправляется на сервер
- проходит некоторое время
- реплика "состояние 1" приходит с сервера и применяется.
  /  
  Получаем в базе СТАРЫЙ вариант записи, в "состояние 1".
- проходит некоторое время, база находится в неправильном состоянии
- реплика "состояние 1" приходит с сервера и применяется.
  База возвращается в актуальное состояние.


Несмотря на то, что это "состояние 1" временное, и в конце концов запись снова придет в "состояние 2",
некоторое время база пребывает в неправильном состоянии, причем база не отстает в актуальности (что было бы нормально),
а именно находится в состоянии, в котором в реальности она _никогда не была_.

Такая проблема характерна для таблиц, которые редактируются после добавления.
И если для справочников (например, "улица") это часто не критично, то для таблиц типа "Заказ и его состояние"
это критично - у нас на некоторое время открывается ранее закрытый заказ.

Если же таблица хранит общее состояние (например, остаток для каждой кассы), то такая ситуация становится катастрофичной и возникает регулярно.
Такие таблицы вообще не рекомендуется отправлять обратно (и следовательно НЕ редактировать их на сервере, а только на станциях).


##### Решение проблемы

Для таблиц, чье состояние должно быть строго актуальным следует для каждой записи держать условный возраст последнего изменения записи.
Это нужно реализовать на триггерах и держать в отдельной "теневой" таблице (например, для таблицы LIC аудит хранится в Z_LIC, а актуальность хранится в ZA_LIC).


##### Неубывание возраста последнего изменения записи

Есть соблазн в качестве возраста использовать дату, но это неустойчиво с точки зрения перевода времени назад,
поэтому лучше использовать _номер_, но это уже неудобно, если запись редактируется одновременно НА РАЗНЫХ филиалах.
Возможно, стоит использовать комбинацию "цифра + дата/время".

В любом случае, при изменении записи на рабочей станции возраст актуальности записи должен **только расти**,
как при прямом редактировании (и тогда за этим следит триггер), так и при применении реплик (тогда за этим следит применятель реплик).


##### Порядок применения реплик

При поступлении реплики они применяется только если ее возраст актуальности _больше_, чем текущий возрасти записи.


##### Ограничения

Поскольку отметка актуальности занимает время и требует места, а применение реплик требует времени на проверку,
следует осторожно выбирать этот режим для таблицы, включая его только для _проблемных_ таблиц (описанных выше)


##### Ограничения

Может, применять реплики только после того, как они получены все, чей возраст не мене нашего?
Как бы не пришлось ждать вечно такого состояния для активно меняющихся таблиц и тормозного сервера! 

