### Решение проблемы удаления влияющих записей (из справочников)

##### Суть проблемы

Известно, что если на рабочей станции удалить запись, на которую были ссылки (напр. из справочника),
попытка удалить эту запись на сервере может окончится неудачно, т.к. на сервере может оказаться больше записей,
ссылающихся на эту запись, чем было на рабочей станции (например, из-за фильтрации баз для рабочих станций).

Также возможно, что одна из рабочих станций удаляет запись, а другая - активно начинает ее использовать,
и общая очередь заполняется вставками, ссылающимися на удаленную запись.
Проблемный сценарий:
1. На станциях А и Б есть запись 1 в справочнике С (С1);
2. Станция А удалила значения справочника С1 (del C1), а в это время станция Б добавила запись 1 в таблицу Т (Т1) с использованием записи С1 (ins T1->C1);
3. Обмен Сервера с А, в общую очередь попала реплика (del C1);
3. Обмен Сервера с Б, в общую очередь попала реплика (ins T1->C1);
4. Применение реплик на станции Б: реплика на удаление из С (del C1) не сможет быть выполнена, а лишь пропущена или заменена на обратную вставку в С (ins С1).
5. Применение реплик на станции А: реплика на вставку в Т (ins T1->C1) не сможет быть обработана, и очередь заблокируется.

##### Решения

В таких ситуациях сервер может выполнить действия по одному из сценариев, выбранных пользователем:

* Полное каскадное удаление. На всех рабочих станциях, и сервере будет выполнена каскадное удаление самой записи
  и всех ссылающихся на нее, т.е. возможно удаление большего количества записей, чем было удалено на рабочей станции.
* Распределенное удаление консенсусом.
  Сервер рассылает команду на удаление записи, и ждет сообщения об успешном удалении со всех станций.
  Если хоть одна из станций не сможет выполнить удаление, сервер всем станциям рассылает команду восстановить запись.
  Если логи не ведутся в виде копии (а только в виде id, как в СО), то спрашивается — как восстановить запись?
  Очень просто. Та рабочая станция, которая не смогла удалить запись присылает серверу свою копию этой записи,
  которая и рассылается обратно по станциям как команда ins.
* Защита от foreignKey при использовании удаленных значений другими станциями.
  Таблицы, которые (с точки зрения разработчика прикладного ПО) являются справочниками,
  записи из которых могут быть удалены на одной рабочей станции, а использованы на другой,
  помечаются в конфигурации как "защищаемые". Тогда триггер на удаление запишет удаляемый вариант записи себе в "хранилище мертвых".
  Если на станцию, где удалили значения справочника, поступят записи, которые используют удаленное значение справочника,
  то есть возможность восстановить ранее напрасно удаленную запись справочника из "хранилища мертвых".
  Записи в "хранилище мертвых" не нужно хранить вечно, очистка хранилища возможна после того,
  как отработает механизм "удаление консенсусом".

* Как вариант вместо "хранилище мертвых", удаляемый вариант записи записывается в саму реплику на удаление. 
  Тогда при возникновении foreignKey при применении других реплик, запись может быть восстановлена путем поиска в репликах.
  Записи в репликах также не нужно хранить вечно, после полной синхронизации возможно удаление старых реплик.

* Зачем??? Удаление с поддержкой прикладного ПО. Дополнительный механизм к первым двум.
  Можно задать условие, по достижении которого всеми станциями будет произведено удаление по первому или второму сценарию.
  Условием может быть, например «Table1.Deleted=1» для удаляемой записи.


#### Замечания по применению реплик


<replica REPLICA_TYPE="10" DT_TO="2021-02-26T20:46:23.000+06:00" DT_FROM="2021-02-26T20:37:12.000+06:00" AGE="20" WS_ID="1"/>

  <table name="COMMENTTIP">
    <rec DELETED="0" NAME="Tip-ins-all" ID="1:1003" Z_OPR="1"/>
    <rec DELETED="0" NAME="" ID="1:1001" Z_OPR="3"/>
    <rec DELETED="0" NAME="" ID="1:1002" Z_OPR="3"/>
    <rec DELETED="0" NAME="" ID="2:1001" Z_OPR="3"/>
    <rec DELETED="0" NAME="" ID="3:1001" Z_OPR="3"/>
    <rec DELETED="0" NAME="" ID="5:1001" Z_OPR="3"/>
  </table>


  <table name="COMMENTTEXT">
    <rec ID="1:1001" Z_OPR="2" COMMENTTEXT="Text-Lic-ins-ws:1--472614502" COMMENTTIP="1:1003" COMMENTDT="2021-02-26T20:35:55.656" PAWNCHITSUBJECT="1:0" PAWNCHIT="1:0" LIC="5:1002"/>
    <rec ID="2:1007" Z_OPR="2" COMMENTTEXT="Text-Lic-ins-ws:2--665490272" COMMENTTIP="1:1003" COMMENTDT="2021-02-26T20:35:55.753" PAWNCHITSUBJECT="1:0" PAWNCHIT="1:0" LIC="5:1002"/>
    <rec ID="3:1004" Z_OPR="2" COMMENTTEXT="Text-Lic-ins-ws:3--506816344" COMMENTTIP="1:1003" COMMENTDT="2021-02-26T20:35:55.782" PAWNCHITSUBJECT="1:0" PAWNCHIT="1:0" LIC="5:1002"/>
    <rec ID="5:1002" Z_OPR="2" COMMENTTEXT="Text-Lic-ins-ws:5-460560354" COMMENTTIP="1:1003" COMMENTDT="2021-02-26T20:35:55.823" PAWNCHITSUBJECT="1:0" PAWNCHIT="1:0" LIC="3:1006"/>
  </table>

Обратите внимание, что надо бы так: в COMMENTTIP сначала добавляется запись, потом апдейтим COMMENTTEXT, а потом возвращаемся к COMMENTTIP и удаляем из нее.