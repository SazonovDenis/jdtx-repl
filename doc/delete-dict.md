### Решение проблемы удаления влияющих записей (из справочников)

##### Суть проблемы

Известно, что если на рабочей станции удалить запись, на которую были ссылки (напр. из справочника),
попытка удалить эту запись на сервере может окончится неудачно, т.к. на сервере может оказаться больше записей,
ссылающихся на эту запись, чем было на рабочей станции (например, из-за фильтрации баз для рабочих станций).

Также возможно, что одна из рабочих станций удаляет запись, а другая - активно начинает ее использовать,
и общая очередь заполняется вставками, ссылающимися на удаленную запись.
Проблемный сценарий:
1. На станциях А и Б есть запись 1 в справочнике С (С1);
2. Станция А удалила значения справочника С1 (del C1), а в это время станция Б добавила запись 1 в таблицу Т (Т1) 
   с использованием записи С1 (ins T1->C1);
3. Обмен Сервера с А, в общую очередь попала реплика (del C1);
3. Обмен Сервера с Б, в общую очередь попала реплика (ins T1->C1);
4. Применение реплик на станции Б: реплика на удаление из С (del C1) не сможет быть выполнена, а лишь пропущена 
   или заменена на обратную вставку в С (ins С1).
5. Применение реплик на станции А: реплика на вставку в Т (ins T1->C1) не сможет быть обработана, и очередь заблокируется.

###### Невозможность искать удаленную репику при регулярной чистке старых реплик

При очистке старых реплик, реплики на удаление записи должны циркулировать в системе не в виде id, а в виде "тела", 
чтобы можно было их когда-нибудь получить и откатить удаление (или нужно "Хранилище снимков").

Проблемный сценарий:
0. Все станции синхронны, старые реплики очищены;
1. На станциях А и Б есть запись 1 в справочнике С (С1);
2. Станция А удалила значения справочника С1 (del C1)
3. Обмен станции А с Сервером, в общую очередь попала реплика (del C1);
4. Станция Б добавила запись 1 в таблицу Т (Т1) с использованием записи С1 (ins T1->C1);
5. Станция Б отправила реплику (ins T1->C1) на сервер;
6. Станция Б удалила запись 1 в таблице Т (del Т1), или отредактировала с использованием другой записи справочника С1 (upd T1->C2);
6. Станция Б удалила запись 1 в справочнике С1 (del С1);
7. Станция Б отправила реплики (del Т1) и (del С1) на сервер;
8. Станция Б способна получить и успешно обработать реплику (del C1) из общей очереди, удалила запись C1 удалена,
   но неспособна обработать свои же реплику (ins T1->C1) и взять запись С1 ей негде,
   а РЕПЛИК С ТЕЛОМ ЗАПИСИ справочника C1 в системе больше нет;
9. Станция А получила реплику от Б (ins T1->C1) и тоже не смогла ее обработать, и взять запись С1 ей негде,
   а РЕПЛИК С ТЕЛОМ ЗАПИСИ справочника C1 в системе больше нет
   
Если бы реплика на удаление от А (del C1) была бы с телом записи, то станция А смогла бы из нее ее восстановить запись C1.
Таким образом вытекает необходимость ОБЯЗАТЕЛЬНО наличия "ХРАНИЛИЩА МЕРТВЫХ" на триггерах с ТЕЛОМ записи.


##### Решения

В таких ситуациях сервер может выполнить действия по одному из сценариев, выбранных пользователем:

* Распределенное удаление консенсусом.
  Сервер рассылает команду на удаление записи, и ждет сообщения об успешном удалении со всех станций.
  Если хоть одна из станций не сможет выполнить удаление, сервер всем станциям рассылает команду восстановить запись.
  Если логи не ведутся в виде копии (а только в виде id, как в СО), то спрашивается — как восстановить запись?
  Очень просто. Та рабочая станция, которая не смогла удалить запись присылает серверу свою копию этой записи,
  которая и рассылается обратно по станциям как команда ins.

* Защита от foreignKey при использовании удаленных значений другими станциями.
  Таблицы, которые (с точки зрения разработчика прикладного ПО) являются справочниками,
  записи из которых могут быть удалены на одной рабочей станции, а использованы на другой,
  помечаются в конфигурации как "защищаемые". Тогда триггер на удаление запишет удаляемый вариант записи себе в "хранилище мертвых".
  Если на станцию, где удалили значения справочника, поступят записи, которые используют удаленное значение справочника,
  то есть возможность восстановить ранее напрасно удаленную запись справочника из "хранилища мертвых".
  Записи в "хранилище мертвых" не нужно хранить вечно, очистка хранилища возможна после того,
  как отработает механизм "удаление консенсусом".

* Как вариант вместо "хранилище мертвых", удаляемый вариант записи записывается в саму реплику на удаление. 
  Тогда при возникновении foreignKey при применении других реплик, запись может быть восстановлена путем поиска в репликах.
  Записи в репликах также не нужно хранить вечно, после полной синхронизации возможно удаление старых реплик.

Хранилище снимков для каждой рабочей станции для защищаемых таблиц. При любом изменении в таблице реплика на извинения
также копируется в хранилище, при смене структуры бд делается копирование всей таблицы в хранилище. При наличии такого
хранилища, можно допустить удаление реплик, которые были применены на всех филиалах, а также удаления аудита, из которых
были приготовлены эти реплики

* Зачем??? Удаление с поддержкой прикладного ПО. Дополнительный механизм к первым двум.
  Можно задать условие, по достижении которого всеми станциями будет произведено удаление по первому или второму сценарию.
  Условием может быть, например «Table1.Deleted=1» для удаляемой записи.

#### Очистка старых реплик

Делается вместе с очисткой почты - сейчас почта удаляется, что затрудняет восстановление базы в ситуации "восстановили из бэкапа"                      


#### Замечания по применению реплик
       
~~~
<replica REPLICA_TYPE="10" DT_TO="2021-02-26T20:46:23.000+06:00" DT_FROM="2021-02-26T20:37:12.000+06:00" AGE="20" WS_ID="1"/>

  <table name="COMMENTTIP">
    <rec DELETED="0" NAME="Tip-ins-all" ID="1:1003" Z_OPR="1"/>
    <rec DELETED="0" NAME="" ID="1:1001" Z_OPR="3"/>
    <rec DELETED="0" NAME="" ID="1:1002" Z_OPR="3"/>
    <rec DELETED="0" NAME="" ID="2:1001" Z_OPR="3"/>
    <rec DELETED="0" NAME="" ID="3:1001" Z_OPR="3"/>
    <rec DELETED="0" NAME="" ID="5:1001" Z_OPR="3"/>
  </table>


  <table name="COMMENTTEXT">
    <rec ID="1:1001" Z_OPR="2" COMMENTTEXT="Text-Lic-ins-ws:1--472614502" COMMENTTIP="1:1003" COMMENTDT="2021-02-26T20:35:55.656" PAWNCHITSUBJECT="1:0" PAWNCHIT="1:0" LIC="5:1002"/>
    <rec ID="2:1007" Z_OPR="2" COMMENTTEXT="Text-Lic-ins-ws:2--665490272" COMMENTTIP="1:1003" COMMENTDT="2021-02-26T20:35:55.753" PAWNCHITSUBJECT="1:0" PAWNCHIT="1:0" LIC="5:1002"/>
    <rec ID="3:1004" Z_OPR="2" COMMENTTEXT="Text-Lic-ins-ws:3--506816344" COMMENTTIP="1:1003" COMMENTDT="2021-02-26T20:35:55.782" PAWNCHITSUBJECT="1:0" PAWNCHIT="1:0" LIC="5:1002"/>
    <rec ID="5:1002" Z_OPR="2" COMMENTTEXT="Text-Lic-ins-ws:5-460560354" COMMENTTIP="1:1003" COMMENTDT="2021-02-26T20:35:55.823" PAWNCHITSUBJECT="1:0" PAWNCHIT="1:0" LIC="3:1006"/>
  </table>
~~~

Обратите внимание, что надо бы так: в COMMENTTIP сначала добавляется запись, потом апдейтим COMMENTTEXT, а потом возвращаемся к COMMENTTIP и удаляем из нее.